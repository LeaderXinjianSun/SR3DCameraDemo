<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.0">
<procedure name="main">
<interface/>
<body>
<l>* get_system_time (MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<l>* open_file ('C:/Users/ABC/Desktop/qwer/'+Month+Day+Hour+Minute+Second+'.csv', 'output', FileHandleData)</l>
<l>* open_file ('C:/Users/ABC/Desktop/qwer/'+Month+Day+Hour+Minute+Second+'pointsgray.csv', 'output', FileHandleData1)</l>
<l>* open_file ('C:/Users/25001858/Desktop/3d_data_test/'+Month+Day+Hour+Minute+Second+'Test'+'.csv', 'output', FileHandleData1)</l>
<l>* fwrite_string (FileHandleData, '1'+','+'2'+','+'3'+','+'4'+','+'5'+','+'6'+'7'+'8')</l>
<l>* fnew_line (FileHandleData)</l>
<l>* fwrite_string (FileHandleData1, '1'+','+'2'+','+'3'+','+'4'+','+'5'+','+'6')</l>
<l>* fnew_line (FileHandleData1)</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2]" as_ord="1">     list_files ('E:/3D掉落数据', ['files','follow_links'], ImageFiles)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,3]" as_ord="1">tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFiles)</l>
<l>get_roi (ROI, 17, 0)</l>
<c>*像素当量,一个像素代表的长度，单位微米</c>
<l>sx:= 0.007</l>
<l>sy:= 0.025</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,2]" as_ord="1">for Index := 0 to |ImageFiles| - 1 by 1</l>
<l>    *read_image (Image, 'E:/CYG项目/RingerButton/0404/GRR/1.tif')</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,3]" as_ord="1">    read_image (Image, ImageFiles[Index]) </l>
<l>     dev_set_check ('give_error')</l>
<l>    threshold (Image, RegionValid, -23000, 45000)</l>
<l>    difference (Image, RegionValid, RegionDifference)</l>
<l>    paint_region (RegionDifference, Image, ImageResult, -25000, 'fill')</l>
<l>    convert_image_type (ImageResult, ImageConverted, 'real')</l>
<l>     scale_image (ImageConverted, ImageScaled, 0.0001, 0.996)</l>
<l>     scale_image (ImageScaled, ImageScaled, 1000, 1000)</l>
<c>     *矫正图片</c>
<l>    get_correct_image (ImageScaled, CorrectImage)</l>
<c>    *获取椭圆特征</c>
<l>   mean_image (CorrectImage, ImageMean, 2, 2)</l>
<l>   var_threshold (ImageMean, Region, 25, 25, 0.4, 40, 'light')</l>
<l>   opening_circle (Region, RegionOpeningCircle, 1)</l>
<l>   connection (RegionOpeningCircle, ConnectedRegionsSelect)</l>
<l>   select_shape (ConnectedRegionsSelect, SelectedEllipse, 'area', 'and', 10000, 17000)</l>
<l>   shape_trans (SelectedEllipse, RegionTrans, 'convex')</l>
<l>*     closing_rectangle1 (SelectedEllipse, RegionClosing, 10, 5)</l>
<l>   fill_up_shape (RegionTrans, RegionFillUp, 'area', 1, 23000)</l>
<l>   opening_rectangle1 (RegionFillUp, RegionOpening, 10, 20)</l>
<l>   opening_rectangle1 (RegionOpening, RegionOpening1, 20, 10)</l>
<l>   connection (RegionOpening1, ConnectedRegions)    </l>
<l>   select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 25000, 45000)    </l>
<l>   select_shape (SelectedRegions, SelectedRegions1, 'width', 'and', 710, 780)</l>
<l>   select_shape (SelectedRegions1, SelectedRegions2, 'column', 'and', 500, 1500)</l>
<l>   sort_region (SelectedRegions2, SortedRegions, 'character', 'true', 'column')</l>
<l>   count_obj (SortedRegions, Number)</l>
<l>*     tuple_index:=[18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19]</l>
<l>   tuple_null:=[]</l>
<l>   for Index1 := 1 to 18 by 1</l>
<l>*        fact_index:=tuple_index[Index1-1]</l>
<l>       select_obj (ROI, ObjectSelected, Index1)</l>
<l>       intersection (ObjectSelected, SortedRegions, RegionIntersection)  </l>
<l>       area_center (RegionIntersection, AreaJudge, RowJudge, ColumnJudge)     </l>
<l>       if (AreaJudge&gt;10000)</l>
<l>           calculate_features (RegionIntersection, ImageMean, 'phi', Features)</l>
<l>           area_center (RegionIntersection, Area, Row, Column)           </l>
<l>           vector_angle_to_rigid (Row, Column, Features, Row, Column, 0, HomMat2D)</l>
<l>           affine_trans_image (ImageMean, ImageAffineTrans, HomMat2D, 'constant', 'false')</l>
<l>           affine_trans_region (RegionIntersection, RegionAffineTrans, HomMat2D, 'nearest_neighbor')</l>
<l>           get_region_points (RegionAffineTrans, Rows, Columns)</l>
<l>           RowsMin:=min(Rows)</l>
<l>           RowsMax:=max(Rows)</l>
<l>           RowAffine:=(RowsMin+RowsMax)/2</l>
<l>           ColumnsMin:=min(Columns)</l>
<l>           ColunmsMax:=max(Columns)</l>
<l>           ColumnAffine:=(ColumnsMin+ColunmsMax)/2</l>
<c>           </c>
<l>           LengthA:=5</l>
<l>           WidthA:=5           </l>
<l>           get_standard_points (ImageAffineTrans, RowAffine, ColumnAffine, RowsStandard, ColumnsStandard, Phi, RowCentre, ColumnCentre)</l>
<l>           gen_region_points (Region2, RowsStandard, ColumnsStandard)</l>
<l>           hom_mat2d_identity (HomMat2DIdentity)</l>
<l>           hom_mat2d_rotate (HomMat2DIdentity, Phi-rad(90), RowCentre, ColumnCentre, HomMat2DRotate)</l>
<l>           affine_trans_point_2d (HomMat2DRotate, RowsStandard, ColumnsStandard, Qy, Qx)</l>
<l>           gen_rectangle2 (RectangleA, [Qy[0],Qy[1],Qy[0],Qy[1]], [Qx[0]+23,Qx[1]+23,Qx[0]+958,Qx[1]+958], [Phi,Phi,Phi,Phi], [LengthA,LengthA,LengthA,LengthA], [WidthA,WidthA,WidthA,WidthA])</l>
<l>           get_points_value (RectangleA, ImageAffineTrans, GrayvalsA, RowsA, ColumnsA)</l>
<l>*            fwrite_string (FileHandleData1, GrayvalsA[0]+','+GrayvalsA[1]+','+GrayvalsA[2]+','+GrayvalsA[3])</l>
<l>*            fnew_line (FileHandleData1)</l>
<l>           LengthD:=3</l>
<l>           WidthD:=3</l>
<l>           deltx:=1.93/sx</l>
<l>           delty:=0.20/sy</l>
<l>           gen_rectangle2 (RectangleD, [RowAffine+delty,RowAffine+delty,RowAffine+delty,RowAffine-delty,RowAffine-delty,RowAffine-delty], [ColumnAffine+deltx,ColumnAffine-0,ColumnAffine-deltx,ColumnAffine-deltx,ColumnAffine-0,ColumnAffine+deltx], [0,0,0,0,0,0], [LengthD,LengthD,LengthD,LengthD,LengthD,LengthD], [WidthD,WidthD,WidthD,WidthD,WidthD,WidthD])</l>
<l>           get_points_value (RectangleD, ImageAffineTrans, GrayvalsD, RowsD, ColumnsD)</l>
<l>           rangea:=GrayvalsA[0]-GrayvalsA[2]</l>
<l>           ranged:=GrayvalsD[2]-GrayvalsD[0]</l>
<c>           </c>
<l>*            fwrite_string (FileHandleData1, GrayvalsD[0]+','+GrayvalsD[1]+','+GrayvalsD[2])</l>
<l>*            fnew_line (FileHandleData1)</l>
<l>*            fwrite_string (FileHandleData1, GrayvalsD[5]+','+GrayvalsD[4]+','+GrayvalsD[3])</l>
<l>*            fnew_line (FileHandleData1)</l>
<c>           </c>
<c>           *A1-74平行度</c>
<l>           gen_rectangle2 (RectangleA1, [Qy[0],RowCentre,Qy[1]], [Qx[0]+23,Qx[1]+23,Qx[1]+23], [Phi,Phi,Phi], [LengthA,LengthA,LengthA], [WidthA,WidthA,WidthA])</l>
<l>           get_points_value (RectangleA1, ImageAffineTrans, GrayvalsA1, RowsA1, ColumnsA1)</l>
<l>           analyze_flatness (ColumnsA*sx*1000, RowsA*sy*1000, GrayvalsA, ColumnsA1*sx*1000, RowsA1*sy*1000, GrayvalsA1, flatnessA1, distanceA1, parallelismA1)</l>
<l>*            fwrite_string (FileHandleData, parallelismA1+',')</l>
<c>           *A2-73平行度</c>
<l>           gen_rectangle2 (RectangleA2, [Qy[0],RowCentre,Qy[1]], [Qx[0]+958,ColumnCentre+958,Qx[1]+958], [Phi,Phi,Phi], [LengthA,LengthA,LengthA], [WidthA,WidthA,WidthA])</l>
<l>           get_points_value (RectangleA2, ImageAffineTrans, GrayvalsA2, RowsA2, ColumnsA2)</l>
<l>            analyze_flatness (ColumnsA*sx*1000, RowsA*sy*1000, GrayvalsA, ColumnsA2*sx*1000, RowsA2*sy*1000, GrayvalsA2, flatnessA2, distanceA2, parallelismA2)</l>
<l>*             fwrite_string (FileHandleData, parallelismA2+',')</l>
<c>            *D面平整度</c>
<l>           analyze_flatness (ColumnsA*sx*1000, RowsA*sy*1000, GrayvalsA, ColumnsD*sx*1000, RowsD*sy*1000, GrayvalsD, flatness, distance, parallelism)</l>
<l>           distance:=distance</l>
<l>           tuple_null:=[tuple_null,1]</l>
<l>*            fwrite_string (FileHandleData, distance[0]+','+distance[1]+','+distance[2]+','+distance[3]+','+distance[4]+','+distance[5])</l>
<l>*            fnew_line (FileHandleData)</l>
<l>       else</l>
<l>           tuple_null:=[tuple_null,0]</l>
<l>*            fwrite_string (FileHandleData,0+','+0+','+0+','+0+','+0+','+0)</l>
<l>*            fnew_line (FileHandleData)</l>
<l>       endif</l>
<l>   endfor</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[3,1]" as_ord="1">endfor</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="get_points_value">
<interface>
<io>
<par name="Rectangle" base_type="iconic" dimension="0"/>
<par name="ImageAffineTrans" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Grayvals" base_type="ctrl" dimension="0"/>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Columns" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Grayvals:=[]</l>
<l>Rows:=[]</l>
<l>Columns:=[]</l>
<l>count_obj (Rectangle, NumberA)</l>
<l>       for Index3 := 1 to NumberA by 1</l>
<l>           select_obj (Rectangle, ObjectSelected1, Index3)</l>
<l>           get_region_points (ObjectSelected1, Row, Column)</l>
<l>           get_grayval (ImageAffineTrans, Row, Column, Grayval)</l>
<l>           GrayvalTemp:=[]</l>
<l>           for Index := 0 to |Grayval|-1 by 1</l>
<l>               if (Grayval[Index]&gt;-2000)</l>
<l>                   GrayvalTemp:=[GrayvalTemp,Grayval[Index]]</l>
<l>               endif       </l>
<l>           endfor</l>
<l>           rang:=max(Grayval)-min(Grayval)</l>
<l>           tuple_sort (GrayvalTemp, SortedGrayval)</l>
<l>           tuple_median (SortedGrayval, MedianGrayval)</l>
<l>           ValidGrayval:=[]</l>
<l>           for Index2 := 0 to |GrayvalTemp|-1 by 1</l>
<l>               a:=SortedGrayval[Index2]</l>
<l>               if ((MedianGrayval-5)&lt;a and (MedianGrayval+5)&gt;a)</l>
<l>                   ValidGrayval:=[ValidGrayval,SortedGrayval[Index2]]</l>
<l>               endif</l>
<l>           endfor</l>
<l>            tuple_mean (ValidGrayval, GrayvalMean)            </l>
<l>            Grayvals := [Grayvals,GrayvalMean]</l>
<l>           area_center (ObjectSelected1, Area, RowTemp, ColumnTemp)</l>
<l>           Rows:=[Rows,RowTemp]</l>
<l>           Columns:=[Columns,ColumnTemp]</l>
<l>       endfor</l>
<l>return ()</l>
</body>
<docu id="get_points_value">
<parameters>
<parameter id="Columns"/>
<parameter id="Grayvals"/>
<parameter id="ImageAffineTrans"/>
<parameter id="Rectangle"/>
<parameter id="Rows"/>
</parameters>
</docu>
</procedure>
<procedure name="analyze_flatness">
<interface>
<ic>
<par name="xs" base_type="ctrl" dimension="0"/>
<par name="ys" base_type="ctrl" dimension="0"/>
<par name="zs" base_type="ctrl" dimension="0"/>
<par name="x" base_type="ctrl" dimension="0"/>
<par name="y" base_type="ctrl" dimension="0"/>
<par name="z" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="flatness" base_type="ctrl" dimension="0"/>
<par name="distance" base_type="ctrl" dimension="0"/>
<par name="parallelism" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* 平整度测量</c>
<c>* 3D坐标</c>
<l>X := xs</l>
<l>Y := ys</l>
<l>Z := zs</l>
<c>* 3D坐标转化为3D模型</c>
<l>gen_object_model_3d_from_points (X, Y, Z, ObjectModel3D)</l>
<c>* 3D模型拟合成平面</c>
<l>ParFitting := ['primitive_type','fitting_algorithm','output_xyz_mapping']</l>
<l>ValFitting := ['plane','least_squares','true']</l>
<c>* Apply the fitting</c>
<l>fit_primitives_object_model_3d (ObjectModel3D, ParFitting, ValFitting, ObjectModel3DOutID)</l>
<c>* 获取拟合参数（法向量，平面中心一点）</c>
<l>get_object_model_3d_params (ObjectModel3DOutID, 'primitive_parameter', primitive_parameter)</l>
<l>get_object_model_3d_params (ObjectModel3DOutID, 'center', center)</l>
<c>* 计算平面方程(a,b,c,d)</c>
<l>a := primitive_parameter[0]</l>
<l>b := primitive_parameter[1]</l>
<l>c := primitive_parameter[2]</l>
<l>d := -1*center[0]*a-center[1]*b-center[2]*c</l>
<c>* 平面度计算</c>
<l>minD := 9999</l>
<l>maxD := -9999</l>
<l>for i := 0 to |X|-1 by 1</l>
<l>    D := a*X[i]+b*Y[i]+c*Z[i]+d</l>
<l>    if (minD&gt;D)</l>
<l>        minD := D</l>
<l>    endif</l>
<l>    if (maxD&lt;D)</l>
<l>        maxD := D</l>
<l>    endif</l>
<l>endfor</l>
<l>flatness := (maxD-minD)/1000</l>
<c>* 点到平面距离</c>
<l>X1 := x</l>
<l>Y1 := y</l>
<l>Z1 := z</l>
<l>d1 := a*a+b*b+c*c</l>
<l>height:=a*X1+b*Y1+c*Z1+d</l>
<l>parallelism:=(max(height)-min(height))/1000</l>
<l>tuple_abs (height, d2)</l>
<l>distance := d2/d1/1000</l>
<l>return ()</l>
</body>
<docu id="analyze_flatness">
<parameters>
<parameter id="distance"/>
<parameter id="flatness"/>
<parameter id="parallelism"/>
<parameter id="x"/>
<parameter id="xs"/>
<parameter id="y"/>
<parameter id="ys"/>
<parameter id="z"/>
<parameter id="zs"/>
</parameters>
</docu>
</procedure>
<procedure name="get_roi">
<interface>
<oo>
<par name="ROI" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="r" base_type="ctrl" dimension="0"/>
<par name="c" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>gen_empty_obj (ROI)</l>
<l>for c1 := 0 to c by 1</l>
<l>    for r1 := 0 to r by 1</l>
<l>*         gen_rectangle2 (Rectangle, 7760-r1*435, 500+c1*820, 0, 400, 210)</l>
<l>        gen_rectangle2 (Rectangle, 7860-r1*440, 900+c1*820, 0, 800, 210)</l>
<l>        concat_obj (ROI, Rectangle, ROI)</l>
<l>    endfor</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_roi">
<parameters>
<parameter id="ROI"/>
<parameter id="c"/>
<parameter id="r"/>
</parameters>
</docu>
</procedure>
<procedure name="get_correct_image">
<interface>
<io>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageAffineTrans" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<l>    threshold (ImageScaled, Region1, 1000, 4000)</l>
<l>    shape_trans (Region1, RegionTrans, 'convex')</l>
<l>    reduce_domain (ImageScaled, RegionTrans, ImageReduced)</l>
<l>    threshold (ImageReduced, Region, -1000, 19100)</l>
<l>    opening_circle (Region, RegionOpening2,35)</l>
<l>    fill_up_shape (RegionOpening2, RegionFillUp1, 'area', 0, 45000)</l>
<l>    opening_rectangle1 (RegionFillUp1, RegionOpening1, 100, 250)</l>
<l>    closing_rectangle1 (RegionOpening1, RegionClosing, 50, 400)</l>
<l>    connection (RegionClosing, ConnectedRegions)</l>
<l>    select_shape_std (ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>    fill_up (SelectedRegions, RegionFillUp)</l>
<l>    shape_trans (RegionFillUp, RegionTrans1, 'convex')</l>
<l>    opening_rectangle1 (RegionTrans1, RegionOpening, 100, 300)</l>
<l>    calculate_features (RegionOpening, ImageScaled, 'phi', Features)</l>
<l>    area_center (RegionOpening, Area1, Row1, Column1) </l>
<l>    get_region_points (RegionOpening, Rows, Columns)</l>
<l>    RowLocal:=min(Rows)</l>
<l>    get_image_size (ImageScaled, Width, Height)</l>
<l>    if (Features&gt;0)</l>
<l>        vector_angle_to_rigid (RowLocal, Column1, Features,150, 590, rad(90), HomMat2D)</l>
<l>    else</l>
<l>        vector_angle_to_rigid (RowLocal, Column1, Features, 150, 590, rad(-90), HomMat2D)</l>
<l>    endif</l>
<l>    affine_trans_image (ImageScaled, ImageAffineTrans, HomMat2D, 'constant', 'false')</l>
<l>    return ()</l>
</body>
<docu id="get_correct_image">
<parameters>
<parameter id="ImageAffineTrans"/>
<parameter id="ImageScaled"/>
</parameters>
</docu>
</procedure>
<procedure name="get_standard_points">
<interface>
<io>
<par name="ImageAffineTrans" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowAffine" base_type="ctrl" dimension="0"/>
<par name="ColumnAffine" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Rows" base_type="ctrl" dimension="0"/>
<par name="Columns" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
<par name="RowCentre" base_type="ctrl" dimension="0"/>
<par name="ColumnCentre" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>           gen_rectangle1 (Rectangle, RowAffine-100, ColumnAffine-520, RowAffine+50, ColumnAffine-430)</l>
<l>           reduce_domain (ImageAffineTrans, Rectangle, ImageReduced)</l>
<l>           var_threshold (ImageReduced, Region3, 25, 25, 0.2, 2, 'light')</l>
<l>           closing_rectangle1 (Region3, RegionClosing, 3, 5)</l>
<l>           opening_circle (Region3, RegionOpening, 2.5)  </l>
<l>           fill_up (RegionOpening, RegionFillUp1)</l>
<l>           opening_rectangle1 (RegionFillUp1, RegionOpening2, 10, 30)</l>
<l>           connection (RegionOpening2, ConnectedRegions1)</l>
<l>           select_shape_std (ConnectedRegions1, SelectedRegions3, 'max_area', 70)</l>
<l>           gen_contour_region_xld (SelectedRegions3, Contours, 'border')</l>
<l>           segment_contours_xld (Contours, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<l>           union_collinear_contours_ext_xld (ContoursSplit, UnionContours, 20, 10, 10, 0.5, 0, -1, 1, 1, 1, 1, 1, 0, 'attr_keep')</l>
<l>           select_contours_xld (UnionContours, SelectedContours, 'contour_length', 100, 200, -0.5, 0.5)</l>
<l>           sort_contours_xld (SelectedContours, SortedContours, 'character', 'true', 'column')</l>
<l>           select_obj (SortedContours, ObjectSelected1, 1)</l>
<l>           fit_line_contour_xld (ObjectSelected1, 'tukey', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)</l>
<l>           line_orientation (RowBegin, ColBegin, RowEnd, ColEnd, Phi)</l>
<l>           RowCentre:=(RowBegin+RowEnd)/2</l>
<l>           ColumnCentre:=(ColBegin+ColEnd)/2</l>
<l>           Rows:=[RowCentre-25,RowCentre+25]</l>
<l>           Columns:=[ColumnCentre,ColumnCentre]</l>
<l>           return ()</l>
</body>
<docu id="get_standard_points">
<parameters>
<parameter id="ColumnAffine"/>
<parameter id="ColumnCentre"/>
<parameter id="Columns"/>
<parameter id="ImageAffineTrans"/>
<parameter id="Phi"/>
<parameter id="RowAffine"/>
<parameter id="RowCentre"/>
<parameter id="Rows"/>
</parameters>
</docu>
</procedure>
</hdevelop>
